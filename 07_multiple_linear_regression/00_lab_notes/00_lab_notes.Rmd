---
title: "Lab Notes"
author: "Chapter 7"
date: "OpenIntro Biostatistics"

fontsize: 11pt
geometry: margin=1in

output:
  pdf_document:
    includes:
      in_header: ../../header.tex
    fig_width: 6.5
    fig_height: 3.5
---

# Overview

1. Introduction to Multiple Regression
    - *OI Biostat* Sections 7.1 and 7.2
    
2. Evaluating Model Fit
    - *OI Biostat* Section 7.3
    
3. Categorical Predictors with Several Levels and Inference in Regression
    - *OI Biostat* Sections 7.4 - 7.6 and 7.9
    
4. Interaction
    - *OI Biostat* Section 7.7
    
5. Model Selection for Explanatory Models
    - *OI Biostat* Section 7.8

Lab 1 introduces the multiple regression model in the context of estimating an association between a response variable and primary predictor of interest while adjusting for possible confounding variables.

Lab 2 discusses the use of residual plots to check assumptions for multiple regression and introduces adjusted $R^2$. 

Lab 3 extends on the topics introduced in Chapter 6, Lab 4 by discussing categorical predictors with more than two levels and generalizing inference in regression to the setting where there are several slope parameters.

Lab 4 introduces the concept of a statistical interaction, specifically in the case of an interaction between a categorical variable and a numerical variable.

Lab 5 discusses explanatory modeling, in which the goal is to construct a model that explains the observed variation in the response variable. This is an application of multiple regression distinct from that presented in Lab 1.

\newpage


# Lab 1: Introduction to Multiple Regression

### Working with Several Predictors

The \textbf{\texttt{lm()}} function is used to fit linear models. It has the following generic structure:

```{r, eval = FALSE}
lm(y ~ x1 + x2, data)
```

where the first argument specifies the variables used in the model; in this example, the model regresses a response variable \texttt{y} against two explanatory variables \texttt{x1} and \texttt{x2}. Additional predictor variables can be added to the model formula with the \texttt{+} symbol.

The following example shows fitting a linear model that predicts BMI from age (in years) and gender using data from \texttt{nhanes.samp.adult.500}, a sample of individuals 21 years of age or older from the NHANES data.

```{r}
#load the data
library(oibiostat)
data("nhanes.samp.adult.500")

#fitting linear model
lm(BMI ~ Age + Gender, data = nhanes.samp.adult.500)
```

\vspace{0.5cm}

*Letting \textsf{R} do the Work: Predicted Values*

The \texttt{predict()} function can be used to evaluate the regression equation for specific $x$-values, or in other words, to calculate $\hat{y}$ values for values of $x$ that were not necessarily observed. To use \texttt{predict()} in this way, specify the $x$-values according to the following generic syntax:

```{r, eval = FALSE}
predict(object, newdata = data.frame( ))
```

where \texttt{object} is the name of the fitted model, and the name of the predictor variable and value at which to evaluate the equation are specified within \texttt{newdata = data.frame()}.

In a model with several variables, values for all variables in the model must be specified to calculate a prediction.

The following example shows calculating $\widehat{BMI}$ for a male individual 60 years of age using the model regressing BMI on age and gender in \texttt{nhanes.samp.adult.500}, then checking the result by explicitly solving the regression equation.

```{r}
#BMI ~ Age + Gender in nhanes.samp.adult.500
model.BMIvsAgeGender = lm(BMI ~ Age + Gender, data = nhanes.samp.adult.500)
predict(model.BMIvsAgeGender, newdata = data.frame(Age = 60, Gender = "male"))

#confirm answer from solving 28.81 + 0.02(60) - 0.95(1)
coef(model.BMIvsAgeGender)[1] + coef(model.BMIvsAgeGender)[2]*60 + 
  coef(model.BMIvsAgeGender)[3]*1
```

### Plotting Points According to a Condition

The following plot was generated by using \texttt{plot( )} to plot a set of points with the associated plot axes; in this example, the cases representing statin non-users were plotted first. Afterwards, the \textbf{\texttt{points( )}} function was used to overlay a set of points onto the existing plot; these points in red represent statin users. The \texttt{points( )} function takes the same arguments as \texttt{plot( )}.

Refer to the notes for Lab 3 for details about using \texttt{COL} to specify colors.

```{r, warning = FALSE, message = FALSE, fig.width = 8, fig.height = 5}
#load the data
library(openintro)
library(oibiostat)
data(prevend.samp)
data(COL)

#create statin.use logical
statin.use = (prevend.samp$Statin == 1)

#plot blue points
plot(prevend.samp$Age[statin.use == FALSE], prevend.samp$RFFT[statin.use == FALSE],
     pch = 21, bg = COL[1, 3], col = COL[1], cex = 1.3,
     xlab = "Age (yrs)", ylab = "RFFT Score",
     main = "RFFT Score versus Age (n = 500)")

#plot red points
points(prevend.samp$Age[statin.use == TRUE], prevend.samp$RFFT[statin.use == TRUE],
     pch = 21, bg = COL[4, 3], col = COL[4], cex = 1.3)

#draw vertical lines
abline(v = 40, lty = 2)
abline(v = 50, lty = 2)
abline(v = 60, lty = 2)
abline(v = 70, lty = 2)
abline(v = 80, lty = 2)
```

\normalsize

\newpage

# Lab 2: Evaluating Model Fit

### Extracting Adjusted $R^2$ from a Model Fit

The adjusted $R^2$ of a model fit can be extracted directly from a model summary with the use of the \texttt{\$} syntax. For example, the following syntax prints the adjusted $R^2$ from the model regressing BMI on age and gender in \texttt{nhanes.samp.adult.500}.

```{r}
#print adjusted R-squared value
summary(model.BMIvsAgeGender)$adj.r.squared
```

### Plotting Points According to Several Conditions

The following plots were generated by defining logical variables for ethnicity and logical variables for age. The logical operator \texttt{\&} was used to succinctly specify which data values should appear in each plot, and specify the display color.

```{r, echo = FALSE}
#load data
library(oibiostat)
data("dds.discr")

#subset the data
dds.subset = dds.discr[dds.discr$ethnicity == "Hispanic" | 
                         dds.discr$ethnicity == "White not Hispanic", ]

#drop unused factor levels
dds.subset$ethnicity = droplevels(dds.subset$ethnicity)

#load colors from openintro
library(openintro)
data(COL)
```


```{r, fig.width = 8, fig.height = 6, message = FALSE}
#create hispanic and white.not.hisp logicals
hispanic = (dds.subset$ethnicity == "Hispanic")
white.not.hisp = (dds.subset$ethnicity == "White not Hispanic")

#create age logicals
younger = (dds.subset$age < 21)
older = (dds.subset$age >= 21)

par(mfrow = c(1, 2))

#plot blue points, white not hispanic
plot(expenditures[white.not.hisp & younger] ~ age[white.not.hisp & younger], 
     data = dds.subset,
     pch = 21, bg = COL[1, 4], col = COL[1], cex = 0.8,
     xlab = "Age (yrs)", ylab = "Expenditures",
     main = "Expenditures vs Age in DDS (0 - 21)")

#plot red points, hispanic
points(expenditures[hispanic & younger] ~ age[hispanic & younger], 
       data = dds.subset, pch = 21, bg = COL[4, 4], col = COL[4],
       cex = 0.8)

#plot blue points, white not hispanic
plot(expenditures[white.not.hisp & older] ~ age[white.not.hisp & older], 
     data = dds.subset,
     pch = 21, bg = COL[1, 4], col = COL[1], cex = 0.8,
     xlab = "Age (yrs)", ylab = "Expenditures",
     main = "Expenditures vs Age in DDS (21+)")

#plot red points, hispanic
points(expenditures[hispanic & older] ~ age[hispanic & older], 
       data = dds.subset, pch = 21, bg = COL[4, 4], col = COL[4],
       cex = 0.8)
```

\newpage

# Lab 3: Categorical Predictors with Several Levels and Inference in Regression

### Color Palettes with RColorBrewer

The \texttt{RColorBrewer} package is a helpful tool for selecting colors. The package provides three types of palettes: sequential palettes, diverging palettes, and qualitative palettes.

  - Sequential palettes are ideal for ordered data that progress across a range from low to high. 
  
  - Diverging palettes place equal emhasis on extremes at both ends of the data range.
  
  - Qualitative palettes are useful for unordered categorical data.

The \textbf{\texttt{brewer.pal()}} function has the generic structure

```{r, eval = FALSE}
brewer.pal(n, name)
```

where the first argument specifies the number of colors and the second specifies the name of the palette. The possible palette choices are shown below.

```{r, echo = FALSE}
library(RColorBrewer)
par(mar=c(6,6,4,8), cex = 0.5)
display.brewer.all()
```

The following example shows a figure created using the \texttt{GnBu} palette, one of the sequential palettes. A color scheme progressing from a light shade to a dark shade highlights the ordinal nature of educational level and adds interpretive value to the visual. 

```{r, fig.width = 4.5, fig.height = 6, warning = FALSE}
#load RColorBrewer package
library(RColorBrewer)

#load data
data("prevend.samp")

#convert Education to a factor
prevend.samp$Education = factor(prevend.samp$Education,
                                levels = c(0, 1, 2, 3),
                                labels = c("Primary", "LowerSecond",
                                           "HigherSecond", "Univ"))

#create plot
plot(RFFT ~ Education, data = prevend.samp,
     xlab = "Educational Level", ylab = "RFFT Score",
     main = "RFFT by Education in PREVEND (n = 500)",
     names = c("Primary", "LowSec", "HighSec", "Univ"),
     col = brewer.pal(4, "GnBu"))
```

### Using Colors from OpenIntro

The core colors used for the *OpenIntro Statistics* textbook are accessible as the \texttt{COL} dataset in the \texttt{openintro} package. 

Each of the seven colors shown below have four levels of transparency, which can be useful when making scatterplots that display a large number of observations.

```{r, echo = FALSE, fig.width = 7, fig.height = 4}
data(COL)
plot(1:7, 7:1, col=COL, pch=19, cex=4, xlab="", ylab="",
     xlim=c(0.5,7.5), ylim=c(-2.5,8), axes=FALSE)
text(1:7, 7:1+0.7, paste("COL[", 1:7, "]", sep=""), cex=0.9)
points(1:7, 7:1-0.7, col=COL[,2], pch=19, cex=4)
points(1:7, 7:1-1.4, col=COL[,3], pch=19, cex=4)
points(1:7, 7:1-2.1, col=COL[,4], pch=19, cex=4)
```

The colors can be accessed with \texttt{COL[]}. A single number within the square brackets identifies each color. For example, \texttt{COL[1]} corresponds to blue. A second number within the square brackets can be optionally specified to change the transparency, where \texttt{4} is the most transparent and \texttt{1} is opaque.

For example, the plot below on the left is made using the *OpenIntro* color package. The dots are outlined in an opaque blue (\texttt{col = COL[1]}) while the fill color is in a transparent blue (\texttt{col = COL[1, 4]}).

```{r, eval = FALSE}
#simulate data
x <- rnorm(250)
error <- rnorm(250, 0, 50)
y <- 1.3*x^2 + 25*x + error

par(mfrow = c(1, 2))

#plot with openintro colors
plot(y ~ x,
     pch = 21, col = COL[1], bg = COL[1, 4])
```

```{r, fig.width = 8, fig.height = 4, echo = FALSE}
#simulate data
x <- rnorm(250)
error <- rnorm(250, 0, 50)
y <- 1.3*x^2 + 25*x + error

par(mfrow = c(1, 2))

#plot with openintro colors
plot(y ~ x,
     pch = 21, col = COL[1], bg = COL[1, 4])

#plot with rgb( )
plot(y ~ x, pch = 21, 
     col = rgb(52, 139, 221, max = 255),
     bg = rgb(62, 160, 221, max = 255, alpha = 100))
```

The plot on the right is made using \texttt{rgb( )}, a function for specifying color using the RGB color codes. The \textbf{\texttt{rgb( )}} function has the generic structure

```{r, eval = FALSE}
rgb(red, green, blue, max, alpha)
```

where \texttt{red}, \texttt{blue}, \texttt{green}, and \texttt{alpha} can be entered as integers if \texttt{max} is set to 255. The setting \texttt{alpha} is used to specify transparency; a value closer to 0 is more transparent. By default, a color specified will be opaque.

```{r, fig.width = 5, fig.height = 4, eval = FALSE}
#plot with rgb( )
plot(y ~ x, pch = 21, 
     col = rgb(52, 139, 221, max = 255),
     bg = rgb(62, 160, 221, max = 255, alpha = 100))
```



\newpage

# Lab 4: Interaction

To fit a model with an interaction term and its main effects, use the \texttt{*} symbol in \texttt{lm()}. The following example shows fitting a linear model that predicts BMI from age, gender, and the interaction between age and gender in \texttt{nhanes.samp.adult.500}.

```{r}
lm(BMI ~ Age*Gender, data = nhanes.samp.adult.500)
```

This is equivalent to explicitly specifying the main effects and the interaction term individually with the \texttt{:} symbol.

```{r}
lm(BMI ~ Age + Gender + Age:Gender, data = nhanes.samp.adult.500)
```

It is also possible to use \texttt{()\string^2}, which indicates to \textsf{R} that all main effects and "second-order" interaction terms should be fit. Interaction terms involving more than two terms are not discussed in this course, but this syntax could be useful in such a setting.

```{r}
lm(BMI ~ (Age + Gender)^2, data = nhanes.samp.adult.500)
```

\newpage

# Lab 5: Model Selection for Explanatory Models

### Scatterplot Matrices

The \textbf{\texttt{pairs()}} function creates a matrix of scatterplots. It has the following generic structure

```{r, eval = FALSE}
pairs(formula, data = )
```
where \texttt{formula} is in the form \texttt{$\sim$ x + y + z}, with each term giving a separate variable in the pairs plot and \texttt{data} specifies the data frame for the variables. The function can also take the same graphical parameters that the \texttt{plot()} function uses.

The following example shows a scatterplot matrix for the variables BMI, age, and gender in \texttt{nhanes.samp.adult.500}.

```{r, fig.width = 5.5, fig.height = 5.5, fig.align = "center"}
pairs(~ BMI + Age + Gender, data = nhanes.samp.adult.500,
      pch = 21, cex = 0.7, bg = COL[1, 3], col = COL[1])
```

### Correlation Matrices

The \texttt{cor()} function was previously introduced to calculate the correlation between two variables. When applied to a matrix, the function will output a correlation matrix of all pairwise correlations.

The \texttt{subset()} command has an argument, \texttt{select}, useful for pulling out the variables of interest prior to generating a correlation matrix.

In the following examples, the variables BMI, height, and weight are subsetted from \texttt{nhanes.samp.adult.500} and stored as a matrix from which a correlation matrix is generated.

```{r}
#subset nhanes.samp.adult.500
nhanes.subset = subset(nhanes.samp.adult.500, select = c(BMI, Height, Weight))

#generate corelation matrix
cor(nhanes.subset, use = "complete.obs")
```

